{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Competitive Programming","text":"<p>My Homepage: https://Kenn3o3.github.io</p> <p>This blog is used to track and share my own studying. </p> <p>I am currently learning from: https://cp-algorithms.com/index.html and doing some coding questions, some coding questions I have done are stored in https://github.com/Kenn3o3/competitive-programming/tree/main/code . </p>"},{"location":"#algebra","title":"Algebra","text":"<ul> <li>Fundamentals</li> </ul>"},{"location":"algebra/fundamental/","title":"Fundamentals","text":""},{"location":"algebra/fundamental/#binary-exponentiation","title":"Binary exponentiation","text":"<p>How to calculate $a^n$ using only $O(log n)$ multiplications instead of $O(n)$ ?</p> <p>we have: $a^{b+c} = a^b \\cdot a^c$ and $a^{2b} = a^b \\cdot a^b = (a^b)^2 $. For $n = 14$, we have $a^{13} = a^{1101_2} = a^8 \\cdot a^4 \\cdot a^1 $. </p> <p>Notice that the number n has exactly $\\lfloor log_2 n \\rfloor$ + 1 digits in base 2, we only need to perform $O(log n)$ multiplications if we know the powers $a^1, a^2, a^4, a^8, ..., a^{2\\lfloor log n \\rfloor}$.</p> <p>since an element in the sequence is just the square of the previous element, it is very easy to compute those.</p> <p>Implementation:</p> <pre><code>long long binpow(long long a, long long b) {\n    long long res = 1;\n    while (b &gt; 0) {\n        if (b &amp; 1)\n            res = res * a;\n        a = a * a;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre>"},{"location":"algebra/fundamental/#problems","title":"Problems","text":"<ol> <li> <p>Computer $x^n$ mod $m$ .</p> <p>the modulo operator doesn't interfere with multiplications (\u200a$a \\cdot b \\bmod m \\equiv (a \\bmod m) \\cdot (b \\bmod m) \\pmod m$\u200a), we can directly use the same code, and just replace every multiplication with a modular multiplication.</p> <p>proof:</p> <ul> <li>$a (\\bmod n) \\equiv \\bar{a} \\iff a = np + \\bar{a}$</li> <li>$b (\\bmod n) \\equiv \\bar{b} \\iff b = nq + \\bar{b}$</li> <li>$ab = n(npq + q\\bar{a} + p\\bar{b}) + \\bar{a} \\bar{b} \\Rightarrow ab = \\bar{a} \\bar{b} (\\bmod n)$</li> </ul> <p>code: <pre><code>long long binpow(long long a, long long b, long long m) {\n    a %= m;\n    long long res = 1;\n    while (b &gt; 0) {\n        if (b &amp; 1)\n            res = res * a % m;\n        a = a * a % m;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre></p> </li> <li> <p>Computer $n$ - th Fibonacci number $F_n$ .</p> </li> <li> <p>You are given a sequence of length \u200a$n$\u200a. Apply to it a given permutation \u200a$k$\u200a times .</p> </li> <li> <p>Given \u200a$n$\u200a points \u200a$p_i$\u200a, apply \u200a$m$\u200a transformations to each of these points. Each transformation can be a shift, a scaling or a rotation around a given axis by a given angle. There is also a \"loop\" operation which applies a given list of transformations \u200a$k$\u200a times (\"loop\" operations can be nested). You should apply all transformations faster than \u200a$O(n \\cdot length)$\u200a, where \u200a$length$\u200a is the total number of transformations to be applied (after unrolling \"loop\" operations).</p> </li> <li> <p>Given a directed unweighted graph of \u200a$n$\u200a vertices, find the number of paths of length \u200a$k$\u200a from any vertex \u200a$u$\u200a to any other vertex \u200a$v$\u200a.</p> </li> <li> <p>Multiply two numbers \u200a$a$\u200a and \u200a$b$\u200a modulo \u200a$m$\u200a. \u200a$a$\u200a and \u200a$b$\u200a fit in the built-in data types, but their product is too big to fit in a 64-bit integer. The idea is to compute \u200a$a \\cdot b \\pmod m$\u200a without using bignum arithmetics.</p> </li> </ol>"},{"location":"algebra/fundamental/#next-step","title":"Next Step","text":""}]}